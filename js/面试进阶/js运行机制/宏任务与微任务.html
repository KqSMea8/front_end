<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
</head>
<body>
<script>
  
  setTimeout(function(){ //宏任务，虽然先执行但是被放到事件队列了
    console.log('1')
  });
  //遇到微任务执行，把.then的放到微任务队列，不是一个队列，拿出来的时候先拿出微任务队列里的
  new Promise(function(resolve){
    console.log('2');
    resolve() ;
  }).then(function(){
    console.log('3') ;
  });
  new Promise(function(resolve){
    console.log('5');
    resolve() ;
  }).then(function(){
    console.log('6')
  });

  console.log('4');
  for (let i = 0 ;i<150000 ;i++){
    if(!(i%40000)){
      console.log(i) ;
    }
  }

</script>
<!--
（1）所有同步任务都在主线程上执行，形成一个执行栈
（2）主线程之外，还存在一个"任务队列"。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
（3）"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，进入执行栈，开始执行。
（4）主线程不断重复上面的第三步

循环的运行机制大致分为以下步骤：

	宏任务一般是：包括整体代码script，setTimeout，setInterval。
	微任务：Promise，process.nextTick。

	先执行宏任务执行完，检查有没有微任务执行，没有继续执行宏任务
	有就执行所有微任务之后再执行宏任务

　　高大上：js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，
	一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。
-->
</body>
</html>