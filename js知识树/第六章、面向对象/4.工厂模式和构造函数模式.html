<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<script>
    //工厂模式
    //用函数来封装以特定接口创建对象
    //缺点：不知道这个对象的类型
    function createPerson(name,age,job){
        var obj = new Object() ;
        obj.name = name ;
        obj.age = age ;
        obj.job = job ;
        obj.sayName = function(){
            console.log(this.name) ;
        }
        return obj ;
    } ;
    var person1 = createPerson("feifei",21,"程序猿") ; 
    console.log(person1) ;

    //构造函数模式
    //对比工厂模式,1.没有显式的创建对象，2.直接将属性和方法赋给了this对象，3.没有return语句
    function Person(name,age,job){//构造函数起名开头应该大写，借鉴其他OO语言，为了和其他函数区别开来
            this.name = name ;
            this.age = age ;
            this.job = job ;
            this.sayName = ()=>{
                console.log(this.name) ;
            }
        } ;
    var person2 = new Person("feifei",21,"程序猿") ; 
    var person3 = new Person("fangfang",21,"幼教") ;

    console.log(person2.sayName == person3.sayName) //false，因为其实this.sayName是new Function()出来的，不同实例上的同名函数不相等的

    /* new Person("feifei",21,"程序猿")经历四个步骤
        1.创建一个新对象
        2.将构造函数的作用域赋给新对象
        3.执行构造函数中的代码(为这个新对象添加属性)
        4.返回新对象
    */
    // person2，person3分别保存着Person的一个不同的实例，两对象都有一个constructur(构造函数)属性，该属性应该指向Person
    console.log(person2,person3) ;
    console.log(person2.constructor == Person) ;//true
    console.log(person3.constructor == Person) ; //true

    //构造函数模式可将它的实例标识为一种特定的类型
    console.log(person2 instanceof Object) ; //true
    console.log(person2 instanceof Person) ; //true
    console.log(person3 instanceof Object) ; //true
    console.log(person3 instanceof Person) ; //true
    
</script>
<body>
    
</body>
</html>